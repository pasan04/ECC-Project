# -*- coding: utf-8 -*-
"""ML_E516.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16gH83H23hB-dRVvuV-9NFg_HCb7M8srG

# **Machine Learning Breast Cancer Data**

Engineer Cloud Computing

**Authors:**

Pasan Kamburugamuwa,
Olusina Ojewola,
Courtney Payton

**Summary**

Throughout this notebook, first we will apply preprocessing to the data by dropping any null values, removing unneccessary columns, and renaming the diagnosis field to represent malignant and benign with numerical type values. Exploratory Data Analysis will be performed to show correlations, and visualizations of the dataset. Finally, Machine learning algorithms of logistic regression, KNN, and Random Forest will be applied on this classification task to compare accuracies.

**Import Statements**
"""

!pip install summarytools

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import os
from summarytools import dfSummary

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report

"""## **1.** Preprocessing"""

colab_path = '/content/drive/MyDrive/Cloud_Computing/Cloud_Computing_Project'
df = pd.read_csv(colab_path + '/Midterm/data.csv')

df.head(5)

"""Only need to run below once"""

df.drop(['id', 'Unnamed: 32'], axis = 1, inplace = True)

df['diagnosis'] = df['diagnosis'].apply(lambda val: 1 if val == 'M' else 0)
df.head(15) ##Double checking changing diagnosis values worked

df.describe()

df.info()

"""See if any null values need to be addressed"""

df.isna().sum()

"""## **2.** Exploratory Data Analysis"""

dfSummary(df)

"""### 2.1 Box Plot"""

sns.boxplot(x='diagnosis', y='radius_mean', hue='diagnosis', data=df)
plt.show()

"""### 2.2 Scatter Plot Tumor Measurements Benign vs. Malignant"""

plt.figure(figsize=(10, 8))
sns.scatterplot(x = 'area_mean', y = 'smoothness_mean', hue = 'diagnosis', data = df)

"""### 2.3 Correlation Map"""

corr = df[['radius_mean', 'texture_mean', 'area_mean', 'smoothness_mean', 'compactness_mean']].corr()
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.show()

"""### 2.4 Finding what values have the highest correlation with diagnosis

Here, I thought it was particularly interesting that concavity showed the highest correlation
"""

corr_matrix = df.corr()
correlation = corr_matrix['diagnosis'].apply(abs).sort_values(ascending=False)
print(correlation)

"""## **3.** Classification Task"""

X = df.drop('diagnosis', axis = 1)
y = df['diagnosis']

"""### 3.1 Splitting Data"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.30, random_state = 0)

scaler = StandardScaler()

X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

"""### 3.2 Logistic Regression"""

lr_model = LogisticRegression()
lr_model.fit(X_train, y_train)
lr_pred = lr_model.predict(X_test)

lr_accuracy = accuracy_score(y_test, lr_pred)
lr_report = classification_report(y_test, lr_pred)

"""### 3.3 K-Nearest Neighbors"""

knn_model = KNeighborsClassifier()
knn_model.fit(X_train, y_train)
knn_pred = knn_model.predict(X_test)

knn_accuracy = accuracy_score(y_test, knn_pred)
knn_report = classification_report(y_test, knn_pred)

"""### 3.4 Random Forest"""

rf_model = RandomForestClassifier()
rf_model.fit(X_train, y_train)
rf_pred = rf_model.predict(X_test)

rf_accuracy = accuracy_score(y_test, rf_pred)
rf_report = classification_report(y_test, rf_pred)

"""## **4.** Results"""

results = {
    'Logistic Regression': {'Accuracy': lr_accuracy, 'Classification Report': lr_report},
    'k-Nearest Neighbors': {'Accuracy': knn_accuracy, 'Classification Report': knn_report},
    'Random Forest': {'Accuracy': rf_accuracy, 'Classification Report': rf_report}
}

# Sort the results by accuracy in ascending order
sorted_results = sorted(results.items(), key=lambda x: x[1]['Accuracy'])

# Print the comparison report
for model, metrics in sorted_results:
    print(f"Model: {model}")
    print(f"Accuracy: {metrics['Accuracy']:.4f}")
    print(f"Classification Report:\n{metrics['Classification Report']}\n")